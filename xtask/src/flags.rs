use std::path::PathBuf;

use crate::arch::Arch;

xflags::xflags! {
	src "./src/flags.rs"

	/// Run custom build command.
	cmd xtask {
		default cmd help {
			/// Print help information.
			optional -h, --help
		}

		/// Build the kernel.
		cmd build
		{
			/// Build for the architecture.
			required --arch arch: Arch
			/// Directory for all generated artifacts.
			optional --target-dir target_dir: PathBuf
			/// Build artifacts in release mode, with optimizations.
			optional -r, --release
			/// Build artifacts with the specified profile.
			optional --profile profile: String
		}

		/// Run clippy for all targets.
		cmd clippy {}
	}
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Xtask {
	pub subcommand: XtaskCmd,
}

#[derive(Debug)]
pub enum XtaskCmd {
	Help(Help),
	Build(Build),
	Clippy(Clippy),
}

#[derive(Debug)]
pub struct Help {
	pub help: bool,
}

#[derive(Debug)]
pub struct Build {
	pub arch: Arch,
	pub target_dir: Option<PathBuf>,
	pub release: bool,
	pub profile: Option<String>,
}

#[derive(Debug)]
pub struct Clippy;

impl Xtask {
	pub const HELP: &'static str = Self::HELP_;

	#[allow(dead_code)]
	pub fn from_env() -> xflags::Result<Self> {
		Self::from_env_()
	}

	#[allow(dead_code)]
	pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
		Self::from_vec_(args)
	}
}
// generated end
